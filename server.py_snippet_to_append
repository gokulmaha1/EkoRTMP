
# --- Program Schedule API ---
class ProgramCreate(BaseModel):
    title: str
    video_path: str
    start_time: datetime.datetime
    end_time: datetime.datetime
    is_active: bool = True

@app.post("/api/programs")
def create_program(prog: ProgramCreate, db: Session = Depends(get_db)):
    # Validate Time
    if prog.end_time <= prog.start_time:
        raise HTTPException(status_code=400, detail="End time must be after start time")
        
    db_prog = Program(
        title=prog.title,
        video_path=prog.video_path,
        start_time=prog.start_time,
        end_time=prog.end_time,
        is_active=prog.is_active
    )
    db.add(db_prog)
    db.commit()
    db.refresh(db_prog)
    return db_prog

@app.get("/api/programs")
def get_programs(db: Session = Depends(get_db)):
    now = datetime.datetime.utcnow()
    # Return future and recent programs
    # Limit to 50 for performance
    return db.query(Program).filter(Program.end_time > now - datetime.timedelta(hours=24)).order_by(Program.start_time.asc()).limit(50).all()

@app.delete("/api/programs/{program_id}")
def delete_program(program_id: int, db: Session = Depends(get_db)):
    prog = db.query(Program).filter(Program.id == program_id).first()
    if prog:
        db.delete(prog)
        db.commit()
    return {"status": "success"}

@app.get("/api/programs/current")
def get_current_program(db: Session = Depends(get_db)):
    now = datetime.datetime.utcnow()
    # Find a program that is active and covers the current time
    prog = db.query(Program).filter(
        Program.is_active == True,
        Program.start_time <= now,
        Program.end_time > now
    ).first()
    
    if prog:
        return prog
    return {} # Empty if no program
